# The Householder module.
# This is a stub module, and will (hopefully, some day) be turned
# into PDL::Fit::Linear, and will include methods besides the
# Householder method, such as SVD and Givens rotations.


############## Version and Documentation ##############
pp_addpm({At => Top}, <<'INTRO_AND_DOCUMENTATION');

BEGIN { 
$VERSION = '0.0.1'
};

use strict;
use warnings;
use PDL;
use Carp 'carp';

# Controls useful error messages:
our $WARN_ON_UNDEF = 1;

=head1 NAME

PDL::Fit::Householder - a pure-PDL linear fitting module that uses the
Householder diagonalization technique.

=head1 VERSION

This document describes PDL::Fit::Householder version 0.0.1

=head1 SYNOPSIS

 use PDL::Fit::Householder;
 # Assume that $x and $y have been loaded or computed elsewhere
 

=head1 DESCRIPTION

This provides linear least squares fitting using Householder
transformations, also known as elementary reflectors.  It is written in
pure PDL, which means that there are no external libraries involved
(though you will need a compiler in order to install it).

A Householder transformation is an orthogonal transformation. Orthogonal
transformations have the virtua that, unlike Gaussian elimination, they
are numerically stable and will not amplify errors in the process of
solving the system.

This module provides one function meant for public consumption, and two
internal functions which can be very useful if you need them.  The
method that you will almost always be using from this package is
C<Householder>, and the two internal functions are C<_Householder> and
C<_backsub>.

=head2 Polynomial Fitting

I think polynomial fitting is the simplest use case, so I will start
with it.  Suppose you have some data, C<$x>.

=cut
INTRO_AND_DOCUMENTATION

# This only matters for CPAN's rendering of the .pd file and does not
# impact the resulting module file:
=head1 FUNCTIONS
=cut

############## Perl Functions ##############
# The primary publically-usable function as well as utility functions.

# Placing these at the middle will ensure that they come after the
# =head1 FUNCTIONS pod in the resulting .pm file.  The function pp_addpm
# defaults to the middle, so this isn't strictly necessary, but I think
# it's good to be explicity:
pp_addpm({At => 'Middle'}, <<'HOUSEHOLDER');

=head2 Householder

=for ref

Fits your supplied data to a polynomial, collection of functions,
or collection of piddles.

Here a basic usage summary:

=for usage

 # The returned value depends on calling context:
 $coefs = $data->Householder(...)
 %results = $data->Householder(...)
 
 # The arguments determine what Householder actually does.
 # Full-blown usage:
 ... = $data->Householder(ORDER, FUNCREF|PIDDLE, FUNCREF|PIDDLE, ..., $t)

=head3 Arguments

=over

=item ORDER

A scalar.  This specifies the order of the polynomial you would like to
use to perform the fit; you must specify C<$t> if you specify an order,
and you must specify only one ORDER in your argument list.

=item FUNCREF

A reference to a function that you want to use in the fit.  All
functions passed to Householder must accept a single piddle argument
because the fitting process is going to call C<func($t)> when it runs.
That also means that you must supply C<$t> if you have any function
references.

=item PIDDLE
An arbitrary data set that you want to use in the fit.  All piddles
must have dimensions compatible with C<$data> (and by extension, with
C<$t>).

=item C<$t>

A collection of times (or more generally, the dependent variable) at
which the polynomial and/or reference functions will be evaluated in the
process of performing the fit.  C<$t> must have dimensions compatible
with C<$data>, and must be the last argument in the list.  You only need
to supply C<$t> if you indicate a polynomial fit or pass function
references.

=back
 
Here are some simple examples:

=for example

 # Fit $data to a third-order polynomial:
 $coefs = $data->Householder(3, $t);
 # Fit $data to a second order polynomial plus the exponential funtion:
 $coefs = $data->Householder(2, &exp, $t);
 
 # You expect one signal to be a linear combination of a number of other
 # signals:
 $coefs = $data->Householder($signal1, $signal2, $signal3);

All piddles (including the time $t) must have dimensions that are
compatible with C<$data>.

=cut

sub Householder {
	my ($data, @args) = @_;
	
	# Croak in void context or if $data isn't a piddle
	barf("Usage: Householder")
		if (not defined wantarray or ref ($data) !~ /PDL/);
	
	# Strip out undefs from the args list
	my $i = 0;
	my $arg_count = 1;
	while ($i < @args) {
		if (defined $args[$i]) {
			$i++;
		}
		else {
			@args = splice (@args, $i, 1);
			carp("Argument $arg_count was undefined in call to Householder")
				if $WARN_ON_UNDEF;
		}
		$arg_count++;
	}
	
	# We need at least one argument after $data:
	barf("Usage: Householder") if (@args < 1);
	
	# The last argument can never be a scalar or a code reference:
	if(ref ($args[-1]) eq '') {
		_my_barf("scalar as last argument\n"
		."The presence of a scalar among your arguments means that you intend to\n"
		."perform a polynomial fit.  However, the dependent variable is assumed\n"
		."to be the last item in your list, so you cannot indicate the order of\n"
		."your fit with your last argument.", -1);
	}
	elsif(ref ($args[-1]) =~ /CODE/) {
		_my_barf("function reference as last argument\n"
		."The presence of a function reference among your arguments means that\n"
		."you intend to fit your data to the supplied function.  However, the\n"
		."dependent variable is assumed to be the last item in your list, so you\n"
		."cannot supply an anonymous function as your last argument.", -1);
	}
	
	my ($t, $poly_order, @stuff_to_fit);

	### Process each argument in @args ###
	
	ARGUMENT: for ($arg_count = 1; @args; $arg_count++) {
		my $arg = shift @args;

		# First see if we've got a scalar:
		if (not ref $arg) {
			# Make sure we've not already set up a polynomial fit:
			if (defined $poly_order) {
				_my_barf("multiple scalars\n"
				."When you supply a scalar to the fit, you indicate that you want to perform\n"
				."a linear fit of the given order, but you seem to have supplied two scalars."
				, $arg_count);
			}

			# save the polynomial order and make sure it's valid:
			$poly_order = +$arg;
			(my $digits) = ($arg =~ /(\d+)/);
			if ($poly_order != $digits) {
				_my_barf("negative or non-integer order\n"
				."When you supply a scalar to the fit, you indicate that you want to perform\n"
				."a linear fit of the given order.  For the current implementation, the\n"
				."order must be an integer greater than or equal to zero.  For negative\n"
				."or non-integer exponents, use an anonymous sub with the desired exponent:\n"
				.'  $data->Householder(3, sub {$_[0]**(-2.3)}, $t);'."\n"
				."That will fit your data to a third-order polynomial and t^-2.3"
				, $arg_count);
			}
			
			# Add polynomial orders to @stuff_to_fit in ascending order
			for (my $i = 0; $i <= $poly_order; $i++) {
				push (@stuff_to_fit, $i);
			}
			
			# Get the time from the end of @_
			unless (defined $t) {
				$t = pop @_;
				_check_piddle($data, $t, -1);
			}
		}

		# Next check for a code reference
		elsif (ref ($arg) =~ /CODE/) {
			push @stuff_to_fit, $arg;
			my ($t, $results) = sequence(10);
			eval { $results = &$arg($data) };
			if ($@) {
				_my_barf("Function reference must be able to process piddles."
					, $arg_count);
			}
			eval { cat($results, $data) };
			if ($@) {
				_my_barf("\nFunction reference must return a piddle with dimensions compatible to its input"
					, $arg_count);
			}

			# Get the time from the end of @_
			unless (defined $t) {
				# function reference cannot be the last argument
				unless (@_) {
				}

				$t = pop @_;
				_check_piddle($data, $t, -1);
			}
		}

		# Next check for a piddle reference
		elsif (ref ($arg) =~ /PDL/) {
			_check_piddle($data, $arg, $arg_count);
			push @stuff_to_fit, $arg;
		}
		
		# They've exhausted their options, so barf:
		else {
			_my_barf("Must be a scalar, function reference, or piddle.", $arg_count);
		}
	}
	
	### Build matrix and copy data for fitting ###
	my @piddles_to_fit;
	foreach(@stuff_to_fit) {
		if (not ref) {
			push @piddles_to_fit, $t ** $_;
		}
		elsif (ref ($_) =~ /CODE/) {
			push @piddles_to_fit, &$_($t);
		}
		elsif (ref ($_) =~ /PDL/) {
			push @piddles_to_fit, $_;
		}
	}
	my $A = cat(@stuff_to_fit)->transpose;
	my $y = $data->copy->dummy(0);

	$y->_Householder($A);
	my $coefs = $y->_backsub($A);
	
	# Eventually return coefficients, residual, method, etc if requested
	return $coefs if (defined wantarray and not wantarray);
	my ($residual);
	return (
		coefs => $coefs,
		residual => $residual,
		method => 'Householder',
		diagonalized_matrix => $A,
		manipulated_results => $y,
	) if (wantarray);
	
}

sub _my_barf {
	my ($message, $arg_count) = @_;
	$message = "incorrect usage of function PDL::Fit::Householder\n"
		."Error with "
		. ($arg_count == -1 ? 'last argument' : "argument $arg_count")
		.': '. $message;
	barf($message);
}

# Utility function that makes sure the supplied $t piddle is good.
# Barfs if it finds trouble.
sub _check_piddle {
	my ($data, $piddle, $arg_count) = @_;
	# Make sure $piddle is a piddle
	if (not defined $piddle) {
		_my_barf("Expected a piddle but got undef.", $arg_count);
	}
	elsif (ref ($piddle) !~ /PDL/) {
		_my_barf("Expected a piddle but got something else.", $arg_count);
	}
	# Make sure the dimensions are compatible
	eval { cat($data, $piddle) };
	if ($@) {
		_my_barf("Piddle has incompatible dimensions.", $arg_count);
	}
}

# add Householder as a PDL object method
*PDL::Householder = \&Householder;

HOUSEHOLDER

pp_add_exported('Householder');


############## PDL::PP Functions ##############

=head2 C<_Householder>

=cut

# _Householder
pp_def('_Householder',
	Pars => 'y(i, m); A(n, m); [t]v(m);',
	Doc => <<'HOUSEHOLDER_DOC',
=for ref

Internal routine that upper-triangularizes a matrix using the
Householder method.

In the process of diagonalizing C<$A>, this function WILL MODIFY both
C<$A> and C<$y>, so don't pass it variables that you intend to use
afterwards!

I would like to add code to process bad values in C<$y> that will simply
get skipped if found.  But I haven't implemented it yet.  Also, I'm not
sure what to do about bad values in C<$A>, though I could simply skip
them, too.  Suggestions would be appreciated.

Here's a simple example:

=for example

 # you must build $y and $A ahead of time
 $y->_Householder($A);
 my $coefs = $y->_backsub($A);

=cut
HOUSEHOLDER_DOC

	Code => q{
		double alpha, beta, gamma;
		int j, k;
		int M = $SIZE(m);
		int N = $SIZE(n);
		threadloop %{
		loop(i) %{
			/* Note n is the number of columns, so n < m for this to work */
			loop(n) %{
				/* Compute alpha and build v */
				alpha = 0;
				for (j = n; j < M; j++) {
					alpha += $A(m => j) * $A(m => j);
					$v(m => j) = $A(m => j);
				}
				alpha = sqrt(alpha);
				if ($A(m => n) > 0)
					alpha = -alpha;
				$v(m => n) -= alpha;
				
				beta = 0;
				for (j = n; j < M; j++) {
					beta += $v(m => j) * $v(m => j);
				}
				
				if (beta != 0) {
					// apply the Householder transformation to the
					// remaining submatrix, column j, row k
					for (j = n; j < N; j++) {
						// Get the dot product of v and the jth
						// column of the submatrix, called gamma:
						gamma = 0;
						for (k = n; k < M; k++)
							gamma += $v(m => k) * $A(n => j, m => k);
						// now subtract a scaled version of v, based
						// on gamma, from the submatrix's jth
						// column:
						for (k = n; k < M; k++)
							$A(n => j, m => k) -= 2 * gamma / beta * $v(m => k);
					}
					
					// apply the Householder transformation to y
					// Get the dot product of v and y:
					gamma = 0;
					for (k = n; k < M; k++)
						gamma += $v(m => k) * $y(m => k);
					
					// subtract a scaled copy of v from y
					for (k = n; k < M; k++) {
						$y(m => k) -= (2 * gamma / beta) * $v(m => k);
					}
				}
			%}
		%}
		%}
	},
);

=head2 C<_backsub>

=cut

pp_def('_backsub',
	Pars => 'y(i, m); A(n, m); [o]coefs(i, n);',
	Doc => <<'BACKSUB_DOC',
=for ref

Internal routine that performs the back-substitution necessary for
solving triangularized systems.

Once you have triangularized your C<$A> matrix using C<_Householder>,
use this method to extract the coefficients.

Here's a simple example:

=for example

 # you must build $y and $A ahead of time
 $y->_Householder($A);
 my $coefs = $y->_backsub($A);

=cut
BACKSUB_DOC
	Code => q{
		int j, k;
		double tmp;
		int N = $SIZE(n);
		threadloop %{
		loop (i) %{
			// Remember, n is the number of columns and must be
			// less than or equal to m.  Start at the lowest-right
			// diagonal entry:
			for (j = N-1; j > -1; j--) {
				tmp = $y(m => j);
				for (k = N-1; k > j; k--) {
					tmp -= $A(n => k, m => j) * $coefs(n => k);
				}
				$coefs(n => j) = tmp / $A(n => j, m => j);
			}
		%}
		%}
	},
);


pp_addpm({At => 'Bot'}, <<'FINAL_DOCUMENTATION');

=head1 DIAGNOSTICS

You can receive a number of complaints from C<PDL::Fit::Householder>.
Most of these complaints are fatal, but some are not.  At the moment
the only complaints that are not fatal involve warnings for undefined
arguments.  These warnings are turned on by default; to turn them off,
set C<$PDL::Fit::Householder::WARN_ON_UNDEF> to a false value.

You will get a general usage error when you attempt to call
C<PDL::Fit::Householder> (1) in void context, (2) with too few arguments,
or (3) on anything that is not a piddle.  Here are some examples of
these errors:

 $data->Householder($series1, $series2);     # BAD - void context
 $coefs = $data->Householder();              # BAD - too few arguments
 $coefs = PDL::Fit::Householder(5, $data);   # BAD - first argument not
                                             #       a piddle

You also might slip-up if you call the function on the class using the
arrow operator, even if the 'first' argument is the piddle you meant:

 $coefs = PDL::Fit->Householder($data, $series1); # BAD - first argument
                                                  #       not a piddle

Other errors typically begin with:

 PDL: incorrect usage of function PDL::Fit::Householder
 Error with argument $arg_count: <short-message>
 <Long-Message>

I hope that the messages are self-explnatory.  If they give you trouble,
the list that follows, keyed by short-message, will hopefully explain
your error in more detail:

=over


=item Expected piddle but got undef
=item Expected a piddle but got something else

You inadvertenly supplied an undefined value or a non-piddle where
C<PDL::Fit::Householder> was expecting a piddle.  This can pretty much
only happen when you have a strange value at the end of your argument
list, or if you want to fit your data to a single function and you
forget to supply the dependent variable.

=item function reference as last argument

The explanation pretty much coveres it.  Here's an example in which you
try to fit your data to a home-spun sequence as well as a function:

 $coefs = $data->Householder($sequence1, $t, \&sin);  # BAD
 $coefs = $data->Householder($sequence1, \&sin, $t);  # GOOD

Remember: if you specify function references or anonymous functions,
you should always end your argument list with the dependent variable.

=item Function reference must be able to process piddles

The function that you passed to C<PDL::Fit::Householder> choked on a
piddle.  This is unlikely but pretty serious.  Double-check that you've
got the right function reference!

=item Function reference must return a piddle with dimensions compatible
to its input

This error indicates that the anonymous function or function you passed
by reference either does not return a piddle or returns a piddle whose
dimensions are not compatible (in a PDL threading sense) with the
input.  Put simply, your function should return a piddle with identical
dimensions to those of the piddle supplied to it.

=item multiple scalars

You should give at most one scalar in your list of arguments, and that
one scalar represents the order of the polynomial you would like to fit
to your data.  You will get this error if you inadvertently supply more
than one scalar, which may indicate a mistaken function reference or
piddle.  This could also happen if you supply a function name without
a leading backslash, as in this:

 $coefs = $data->Householder(sin, cos, $t);      # BAD - must reference funcs
 $coefs = $data->Householder(\&sin, \&cos, $t);  # GOOD - properly referenced

=item Must be a scalar, function reference, or piddle

The argument in question is not a scalar, function reference, or piddle.
This could happen if you manage to pass an anonymous array or hash, or
of you pass in an object.

=item negative or non-integer order

At the moment, polynomial fits only expect non-negative integer orders.
So if you provide a scalar for a polynomial fit, be sure it's an
integer:

 $coefs = $data->Householder(3.2, $t);  # BAD - must be an integer
 $coefs = $data->Householder(-3, $t);   # BAD - must be non-negative
 $coefs = $data->Householder(3, $t);    # GOOD - non-negative integer

=item Piddle has incompatible dimensions

You properly supplied a piddle, but its dimensions are not compatible
with your data's dimensions.  For example, C<sequence(3)> and
C<sequence(5)> would give piddles with incompatible dimensions.

=item scalar as last argument

The explanation pretty much coveres it.  Here's an example in which you
try to fit your data to a home-spun sequence as well as a second-order
polynomial:

 $coefs = $data->Householder($sequence1, $t, 2);  # BAD
 $coefs = $data->Householder($sequence1, 2, $t);  # GOOD

Remember: if you specify polynomial fitting, you should always end your
argument list with the dependent variable.

=back

=head1 AUTHOR

David Mertens  C<< <mertens2@illinois.edu> >>

=head1 LICENCE AND COPYRIGHT

Copyright (c) 2010, David Mertens C<< <mertens2@illinois.edu> >>. All rights reserved.

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See L<perlartistic>.


=head1 DISCLAIMER OF WARRANTY

BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.


=cut

FINAL_DOCUMENTATION
